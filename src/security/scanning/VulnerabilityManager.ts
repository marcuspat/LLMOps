/**
 * Vulnerability Management System
 * Advanced vulnerability analysis, risk assessment, and remediation management
 */

import { SecurityConfig } from '../core/SecurityConfig.js';
import { Vulnerability, SecurityRecommendation } from '../core/SecurityFramework.js';

export class VulnerabilityManager {
  private config: SecurityConfig;
  private vulnerabilityCache: Map<string, CachedVulnerability> = new Map();
  private riskMatrix: RiskMatrix;
  private remediationStrategies: RemediationStrategy[];

  constructor(config: SecurityConfig) {
    this.config = config;
    this.riskMatrix = this.initializeRiskMatrix();
    this.remediationStrategies = this.initializeRemediationStrategies();
  }

  /**
   * Analyze scan results and provide comprehensive vulnerability assessment
   */
  async analyzeResults(scanResults: any): Promise<any> {
    const analysis = await this.performComprehensiveAnalysis(scanResults);
    return analysis;
  }

  /**
   * Get vulnerability trends over time
   */
  async getTrends(timeframe: any): Promise<VulnerabilityTrends> {
    // Implementation would analyze historical vulnerability data
    return {
      timeframe,
      totalVulnerabilities: 0,
      newVulnerabilities: 0,
      resolvedVulnerabilities: 0,
      trends: [],
      severityBreakdown: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      categoryBreakdown: {
        dependencies: 0,
        code: 0,
        configuration: 0,
        infrastructure: 0
      }
    };
  }

  /**
   * Generate remediation recommendation for a specific vulnerability
   */
  async getRecommendation(vulnerability: Vulnerability): Promise<SecurityRecommendation | null> {
    const strategy = this.findRemediationStrategy(vulnerability);
    if (!strategy) return null;

    const riskScore = this.calculateRiskScore(vulnerability);
    const priority = this.calculatePriority(vulnerability, riskScore);

    return {
      vulnerabilityId: vulnerability.id,
      priority,
      action: strategy.description,
      effort: this.estimateEffort(vulnerability),
      impact: this.estimateImpact(vulnerability),
      deadline: this.calculateDeadline(vulnerability, priority)
    };
  }

  private async performComprehensiveAnalysis(scanResults: any): Promise<any> {
    const vulnerabilities = this.extractAllVulnerabilities(scanResults);

    // Deduplicate vulnerabilities
    const uniqueVulnerabilities = this.deduplicateVulnerabilities(vulnerabilities);

    // Calculate risk scores and prioritize
    const assessedVulnerabilities = await Promise.all(
      uniqueVulnerabilities.map(vuln => this.assessVulnerability(vuln))
    );

    // Group by categories
    const categorizedVulnerabilities = this.categorizeVulnerabilities(assessedVulnerabilities);

    // Generate remediation plan
    const remediationPlan = await this.generateRemediationPlan(assessedVulnerabilities);

    return {
      vulnerabilities: assessedVulnerabilities,
      categories: categorizedVulnerabilities,
      summary: this.generateSummary(assessedVulnerabilities),
      riskScore: this.calculateOverallRiskScore(assessedVulnerabilities),
      remediationPlan
    };
  }

  private extractAllVulnerabilities(scanResults: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Extract from dependency scan
    if (scanResults.dependencies?.vulnerabilities) {
      vulnerabilities.push(...scanResults.dependencies.vulnerabilities.map((dep: any) => dep.vulnerability));
    }

    // Extract from code scan
    if (scanResults.code?.issues) {
      vulnerabilities.push(...scanResults.code.issues.map((issue: any) => ({
        id: issue.ruleId,
        type: 'code',
        severity: issue.severity,
        description: issue.message,
        location: `${issue.file}:${issue.line}`,
        remediation: this.generateCodeRemediation(issue)
      })));
    }

    // Extract from configuration scan
    if (scanResults.configuration?.issues) {
      vulnerabilities.push(...scanResults.configuration.issues.map((issue: any) => ({
        id: `CONFIG-${issue.parameter}`,
        type: 'configuration',
        severity: issue.severity,
        description: issue.parameter,
        location: issue.file,
        remediation: issue.recommendedValue
      })));
    }

    // Extract from infrastructure scan
    if (scanResults.infrastructure?.issues) {
      vulnerabilities.push(...scanResults.infrastructure.issues.map((issue: any) => ({
        id: `INFRA-${issue.service}-${issue.issue}`,
        type: 'infrastructure',
        severity: issue.severity,
        description: issue.issue,
        location: issue.service,
        remediation: issue.recommendation
      })));
    }

    return vulnerabilities;
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const unique = new Map<string, Vulnerability>();

    for (const vuln of vulnerabilities) {
      const key = this.generateVulnerabilityKey(vuln);
      if (!unique.has(key) || this.isMoreSevere(vuln, unique.get(key)!)) {
        unique.set(key, vuln);
      }
    }

    return Array.from(unique.values());
  }

  private async assessVulnerability(vulnerability: Vulnerability): Promise<AssessedVulnerability> {
    const riskScore = this.calculateRiskScore(vulnerability);
    const exploitability = this.assessExploitability(vulnerability);
    const impact = this.assessImpact(vulnerability);

    return {
      ...vulnerability,
      riskScore,
      exploitability,
      impact,
      priority: this.calculatePriority(vulnerability, riskScore),
      recommendedActions: await this.generateRecommendedActions(vulnerability)
    };
  }

  private calculateRiskScore(vulnerability: Vulnerability): number {
    let baseScore = 0;

    // Base score from severity
    switch (vulnerability.severity) {
      case 'critical': baseScore = 9; break;
      case 'high': baseScore = 7; break;
      case 'medium': baseScore = 5; break;
      case 'low': baseScore = 2; break;
    }

    // CVSS score adjustment if available
    if (vulnerability.cvssScore) {
      baseScore = vulnerability.cvssScore;
    }

    // Type-specific adjustments
    const typeMultipliers: Record<string, number> = {
      'dependency': 1.2,      // External dependencies are often more critical
      'code': 1.0,           // Code issues are standard risk
      'configuration': 0.8,  // Config issues might be easier to fix
      'infrastructure': 1.1   // Infrastructure issues can affect multiple services
    };

    const typeMultiplier = typeMultipliers[vulnerability.type] || 1.0;
    return Math.min(10, baseScore * typeMultiplier);
  }

  private assessExploitability(vulnerability: Vulnerability): ExploitabilityAssessment {
    // Assess how easily the vulnerability can be exploited
    const factors: ExploitabilityFactor[] = [];

    // Location-based exploitability
    if (vulnerability.location.includes('frontend') || vulnerability.location.includes('client')) {
      factors.push({
        factor: 'exposed-surface',
        score: 0.8,
        description: 'Client-side vulnerability exposed to users'
      });
    }

    if (vulnerability.location.includes('api') || vulnerability.location.includes('endpoint')) {
      factors.push({
        factor: 'network-accessible',
        score: 0.9,
        description: 'Network-accessible vulnerability'
      });
    }

    // Type-based exploitability
    if (vulnerability.description.includes('injection') || vulnerability.description.includes('xss')) {
      factors.push({
        factor: 'common-attack-vector',
        score: 0.9,
        description: 'Common attack vector with known exploits'
      });
    }

    if (vulnerability.cve) {
      factors.push({
        factor: 'public-disclosure',
        score: 0.7,
        description: 'Publicly disclosed vulnerability'
      });
    }

    const totalScore = factors.reduce((sum, factor) => sum + factor.score, 0) / Math.max(1, factors.length);

    return {
      overallScore: totalScore,
      factors,
      easeOfExploitation: this.categorizeEaseOfExploitation(totalScore)
    };
  }

  private assessImpact(vulnerability: Vulnerability): ImpactAssessment {
    // Assess the potential impact if exploited
    const impactFactors: ImpactFactor[] = [];

    // Data sensitivity impact
    if (vulnerability.location.includes('auth') || vulnerability.location.includes('user')) {
      impactFactors.push({
        factor: 'data-privacy',
        severity: 'high',
        description: 'Could expose sensitive user data'
      });
    }

    if (vulnerability.location.includes('database') || vulnerability.location.includes('storage')) {
      impactFactors.push({
        factor: 'data-integrity',
        severity: 'medium',
        description: 'Could affect data integrity'
      });
    }

    // System impact
    if (vulnerability.type === 'infrastructure') {
      impactFactors.push({
        factor: 'system-availability',
        severity: 'high',
        description: 'Could affect system availability'
      });
    }

    if (vulnerability.description.includes('privilege') || vulnerability.description.includes('escalation')) {
      impactFactors.push({
        factor: 'privilege-escalation',
        severity: 'critical',
        description: 'Could lead to privilege escalation'
      });
    }

    return {
      confidentialityImpact: this.assessConfidentialityImpact(vulnerability),
      integrityImpact: this.assessIntegrityImpact(vulnerability),
      availabilityImpact: this.assessAvailabilityImpact(vulnerability),
      factors: impactFactors
    };
  }

  private categorizeVulnerabilities(vulnerabilities: AssessedVulnerability[]): CategorizedVulnerabilities {
    return {
      bySeverity: this.groupBySeverity(vulnerabilities),
      byType: this.groupByType(vulnerabilities),
      byRiskScore: this.groupByRiskScore(vulnerabilities),
      byLocation: this.groupByLocation(vulnerabilities),
      byExploitability: this.groupByExploitability(vulnerabilities)
    };
  }

  private generateSummary(vulnerabilities: AssessedVulnerability[]): VulnerabilitySummary {
    const total = vulnerabilities.length;
    const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
    const high = vulnerabilities.filter(v => v.severity === 'high').length;
    const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
    const low = vulnerabilities.filter(v => v.severity === 'low').length;

    const avgRiskScore = vulnerabilities.reduce((sum, v) => sum + v.riskScore, 0) / Math.max(1, total);
    const highRiskCount = vulnerabilities.filter(v => v.riskScore >= 7).length;

    return {
      totalVulnerabilities: total,
      severityBreakdown: { critical, high, medium, low },
      averageRiskScore: Math.round(avgRiskScore * 100) / 100,
      highRiskVulnerabilities: highRiskCount,
      mostCommonType: this.getMostCommonType(vulnerabilities),
      highestRiskVulnerability: this.getHighestRiskVulnerability(vulnerabilities)
    };
  }

  private calculateOverallRiskScore(vulnerabilities: AssessedVulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;

    const weightedScores = vulnerabilities.map(v => {
      const severityWeight = this.getSeverityWeight(v.severity);
      const exploitabilityWeight = v.exploitability.overallScore;
      const impactWeight = this.calculateImpactWeight(v.impact);

      return v.riskScore * severityWeight * exploitabilityWeight * impactWeight;
    });

    const totalWeightedScore = weightedScores.reduce((sum, score) => sum + score, 0);
    const totalWeight = vulnerabilities.length * 10; // Maximum possible weight per vulnerability

    return Math.round((totalWeightedScore / totalWeight) * 100) / 100;
  }

  private async generateRemediationPlan(vulnerabilities: AssessedVulnerability[]): Promise<RemediationPlan> {
    // Sort by priority (highest first)
    const sortedVulns = vulnerabilities.sort((a, b) => b.priority - a.priority);

    const phases: RemediationPhase[] = [];

    // Phase 1: Critical vulnerabilities (immediate action)
    const criticalVulns = sortedVulns.filter(v => v.severity === 'critical');
    if (criticalVulns.length > 0) {
      phases.push({
        phase: 1,
        title: 'Critical Vulnerabilities - Immediate Action Required',
        vulnerabilities: criticalVulns,
        estimatedEffort: this.calculatePhaseEffort(criticalVulns),
        deadline: this.calculatePhaseDeadline(1),
        dependencies: []
      });
    }

    // Phase 2: High vulnerabilities (within 1 week)
    const highVulns = sortedVulns.filter(v => v.severity === 'high');
    if (highVulns.length > 0) {
      phases.push({
        phase: 2,
        title: 'High Risk Vulnerabilities - 1 Week Timeline',
        vulnerabilities: highVulns,
        estimatedEffort: this.calculatePhaseEffort(highVulns),
        deadline: this.calculatePhaseDeadline(2),
        dependencies: phases.map(p => p.phase)
      });
    }

    // Phase 3: Medium vulnerabilities (within 1 month)
    const mediumVulns = sortedVulns.filter(v => v.severity === 'medium');
    if (mediumVulns.length > 0) {
      phases.push({
        phase: 3,
        title: 'Medium Risk Vulnerabilities - 1 Month Timeline',
        vulnerabilities: mediumVulns,
        estimatedEffort: this.calculatePhaseEffort(mediumVulns),
        deadline: this.calculatePhaseDeadline(3),
        dependencies: phases.map(p => p.phase)
      });
    }

    // Phase 4: Low vulnerabilities (routine maintenance)
    const lowVulns = sortedVulns.filter(v => v.severity === 'low');
    if (lowVulns.length > 0) {
      phases.push({
        phase: 4,
        title: 'Low Risk Vulnerabilities - Routine Maintenance',
        vulnerabilities: lowVulns,
        estimatedEffort: this.calculatePhaseEffort(lowVulns),
        deadline: this.calculatePhaseDeadline(4),
        dependencies: phases.map(p => p.phase)
      });
    }

    return {
      phases,
      totalEstimatedEffort: phases.reduce((sum, phase) => sum + phase.estimatedEffort, 0),
      recommendedTimeline: this.generateRecommendedTimeline(phases),
      resourceRequirements: this.calculateResourceRequirements(phases)
    };
  }

  // Helper methods
  private initializeRiskMatrix(): RiskMatrix {
    return {
      // Probability vs Impact matrix
      matrix: {
        // Impact: Critical, High, Medium, Low
        // Probability: Very Likely, Likely, Possible, Unlikely
        'very-likely': { critical: 10, high: 8, medium: 6, low: 4 },
        'likely': { critical: 9, high: 7, medium: 5, low: 3 },
        'possible': { critical: 7, high: 6, medium: 4, low: 2 },
        'unlikely': { critical: 5, high: 4, medium: 3, low: 1 }
      }
    };
  }

  private initializeRemediationStrategies(): RemediationStrategy[] {
    return [
      {
        vulnerabilityType: 'dependency',
        patterns: ['outdated', 'vulnerable', 'cve'],
        description: 'Update dependency to latest secure version',
        effortLevel: 'low',
        automationLevel: 'high',
        codeExamples: ['npm update package-name', 'pip install --upgrade package-name']
      },
      {
        vulnerabilityType: 'code',
        patterns: ['injection', 'xss', 'csrf'],
        description: 'Implement proper input validation and output encoding',
        effortLevel: 'medium',
        automationLevel: 'medium',
        codeExamples: ['Use parameterized queries', 'Implement CSRF tokens', 'Sanitize user input']
      },
      {
        vulnerabilityType: 'configuration',
        patterns: ['security', 'auth', 'encryption'],
        description: 'Update security configuration following best practices',
        effortLevel: 'low',
        automationLevel: 'high',
        codeExamples: ['Enable security headers', 'Configure secure cookies', 'Set proper CORS policies']
      },
      {
        vulnerabilityType: 'infrastructure',
        patterns: ['docker', 'kubernetes', 'cloud'],
        description: 'Update infrastructure configuration for security',
        effortLevel: 'medium',
        automationLevel: 'medium',
        codeExamples: ['Use non-root containers', 'Implement network policies', 'Enable encryption at rest']
      }
    ];
  }

  private generateVulnerabilityKey(vulnerability: Vulnerability): string {
    return `${vulnerability.type}-${vulnerability.location}-${vulnerability.description}`;
  }

  private isMoreSevere(vuln1: Vulnerability, vuln2: Vulnerability): boolean {
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    return severityOrder[vuln1.severity] > severityOrder[vuln2.severity];
  }

  private findRemediationStrategy(vulnerability: Vulnerability): RemediationStrategy | null {
    return this.remediationStrategies.find(strategy =>
      strategy.vulnerabilityType === vulnerability.type &&
      strategy.patterns.some(pattern =>
        vulnerability.description.toLowerCase().includes(pattern.toLowerCase())
      )
    ) || null;
  }

  private calculatePriority(vulnerability: Vulnerability, riskScore: number): number {
    const severityWeight = this.getSeverityWeight(vulnerability.severity);
    return Math.round(riskScore * severityWeight * 10);
  }

  private getSeverityWeight(severity: string): number {
    switch (severity) {
      case 'critical': return 1.5;
      case 'high': return 1.2;
      case 'medium': return 1.0;
      case 'low': return 0.8;
      default: return 1.0;
    }
  }

  private estimateEffort(vulnerability: Vulnerability): 'low' | 'medium' | 'high' {
    const strategy = this.findRemediationStrategy(vulnerability);
    return strategy?.effortLevel || 'medium';
  }

  private estimateImpact(vulnerability: Vulnerability): string {
    return `Fixing this vulnerability will reduce security risk by ${vulnerability.severity === 'critical' ? '90%' : vulnerability.severity === 'high' ? '70%' : vulnerability.severity === 'medium' ? '50%' : '30%'}`;
  }

  private calculateDeadline(vulnerability: Vulnerability, priority: number): string {
    const now = new Date();
    let daysToAdd = 30; // Default for low priority

    if (vulnerability.severity === 'critical') {
      daysToAdd = 1;
    } else if (vulnerability.severity === 'high') {
      daysToAdd = 7;
    } else if (vulnerability.severity === 'medium') {
      daysToAdd = 30;
    } else if (vulnerability.severity === 'low') {
      daysToAdd = 90;
    }

    const deadline = new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
    return deadline.toISOString().split('T')[0];
  }

  private generateCodeRemediation(issue: any): string {
    const remediations: Record<string, string> = {
      'injection': 'Use parameterized queries or prepared statements',
      'xss': 'Implement proper output encoding and CSP headers',
      'hardcoded-password': 'Use environment variables or secret management',
      'weak-cryptography': 'Use stronger encryption algorithms',
      'command-injection': 'Avoid shell commands or use proper sanitization'
    };

    for (const [key, value] of Object.entries(remediations)) {
      if (issue.type.includes(key) || issue.message.toLowerCase().includes(key)) {
        return value;
      }
    }

    return 'Review and fix security issue following OWASP guidelines';
  }

  private categorizeEaseOfExploitation(score: number): 'very-easy' | 'easy' | 'moderate' | 'difficult' | 'very-difficult' {
    if (score >= 0.9) return 'very-easy';
    if (score >= 0.7) return 'easy';
    if (score >= 0.5) return 'moderate';
    if (score >= 0.3) return 'difficult';
    return 'very-difficult';
  }

  private assessConfidentialityImpact(vulnerability: Vulnerability): 'none' | 'low' | 'medium' | 'high' | 'very-high' {
    if (vulnerability.location.includes('auth') || vulnerability.location.includes('password')) return 'high';
    if (vulnerability.location.includes('database') || vulnerability.location.includes('user-data')) return 'medium';
    if (vulnerability.type === 'infrastructure') return 'low';
    return 'none';
  }

  private assessIntegrityImpact(vulnerability: Vulnerability): 'none' | 'low' | 'medium' | 'high' | 'very-high' {
    if (vulnerability.description.includes('write') || vulnerability.description.includes('modify')) return 'high';
    if (vulnerability.type === 'code' && vulnerability.description.includes('injection')) return 'medium';
    return 'none';
  }

  private assessAvailabilityImpact(vulnerability: Vulnerability): 'none' | 'low' | 'medium' | 'high' | 'very-high' {
    if (vulnerability.type === 'infrastructure') return 'high';
    if (vulnerability.description.includes('dos') || vulnerability.description.includes('denial')) return 'high';
    return 'none';
  }

  private calculateImpactWeight(impact: ImpactAssessment): number {
    const weightMap: Record<string, number> = {
      'none': 1.0,
      'low': 1.2,
      'medium': 1.5,
      'high': 1.8,
      'very-high': 2.0
    };

    const maxImpact = Math.max(
      weightMap[impact.confidentialityImpact],
      weightMap[impact.integrityImpact],
      weightMap[impact.availabilityImpact]
    );

    return maxImpact;
  }

  private groupBySeverity(vulnerabilities: AssessedVulnerability[]): Record<string, AssessedVulnerability[]> {
    const groups: Record<string, AssessedVulnerability[]> = {
      critical: [],
      high: [],
      medium: [],
      low: []
    };

    vulnerabilities.forEach(v => {
      groups[v.severity].push(v);
    });

    return groups;
  }

  private groupByType(vulnerabilities: AssessedVulnerability[]): Record<string, AssessedVulnerability[]> {
    const groups: Record<string, AssessedVulnerability[]> = {};

    vulnerabilities.forEach(v => {
      if (!groups[v.type]) groups[v.type] = [];
      groups[v.type].push(v);
    });

    return groups;
  }

  private groupByRiskScore(vulnerabilities: AssessedVulnerability[]): Record<string, AssessedVulnerability[]> {
    const groups: Record<string, AssessedVulnerability[]> = {
      'critical-risk': [],
      'high-risk': [],
      'medium-risk': [],
      'low-risk': []
    };

    vulnerabilities.forEach(v => {
      if (v.riskScore >= 8) groups['critical-risk'].push(v);
      else if (v.riskScore >= 6) groups['high-risk'].push(v);
      else if (v.riskScore >= 4) groups['medium-risk'].push(v);
      else groups['low-risk'].push(v);
    });

    return groups;
  }

  private groupByLocation(vulnerabilities: AssessedVulnerability[]): Record<string, AssessedVulnerability[]> {
    const groups: Record<string, AssessedVulnerability[]> = {};

    vulnerabilities.forEach(v => {
      const location = v.location.split(':')[0]; // Get file/directory only
      if (!groups[location]) groups[location] = [];
      groups[location].push(v);
    });

    return groups;
  }

  private groupByExploitability(vulnerabilities: AssessedVulnerability[]): Record<string, AssessedVulnerability[]> {
    const groups: Record<string, AssessedVulnerability[]> = {
      'very-easy': [],
      'easy': [],
      'moderate': [],
      'difficult': [],
      'very-difficult': []
    };

    vulnerabilities.forEach(v => {
      groups[v.exploitability.easeOfExploitation].push(v);
    });

    return groups;
  }

  private getMostCommonType(vulnerabilities: AssessedVulnerability[]): string {
    const typeCounts = vulnerabilities.reduce((counts, v) => {
      counts[v.type] = (counts[v.type] || 0) + 1;
      return counts;
    }, {} as Record<string, number>);

    return Object.entries(typeCounts).sort(([,a], [,b]) => b - a)[0]?.[0] || 'unknown';
  }

  private getHighestRiskVulnerability(vulnerabilities: AssessedVulnerability[]): AssessedVulnerability | null {
    return vulnerabilities.reduce((highest, current) =>
      current.riskScore > (highest?.riskScore || 0) ? current : highest
    , null as AssessedVulnerability | null);
  }

  private calculatePhaseEffort(vulnerabilities: AssessedVulnerability[]): number {
    const effortMap: Record<string, number> = {
      'low': 1,
      'medium': 3,
      'high': 5
    };

    return vulnerabilities.reduce((total, v) => {
      const effort = this.estimateEffort(v);
      return total + (effortMap[effort] || 3);
    }, 0);
  }

  private calculatePhaseDeadline(phase: number): string {
    const now = new Date();
    let daysToAdd = 0;

    switch (phase) {
      case 1: daysToAdd = 1; break;     // Critical: 1 day
      case 2: daysToAdd = 7; break;     // High: 1 week
      case 3: daysToAdd = 30; break;    // Medium: 1 month
      case 4: daysToAdd = 90; break;    // Low: 3 months
    }

    const deadline = new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
    return deadline.toISOString().split('T')[0];
  }

  private generateRecommendedTimeline(phases: RemediationPhase[]): string {
    if (phases.length === 0) return 'No remediation required';

    const totalDays = phases.reduce((total, phase) => {
      const deadline = new Date(phase.deadline);
      const now = new Date();
      const days = Math.ceil((deadline.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      return Math.max(total, days);
    }, 0);

    return `${totalDays} days (${Math.ceil(totalDays / 7)} weeks) for complete remediation`;
  }

  private calculateResourceRequirements(phases: RemediationPhase[]): ResourceRequirement {
    const totalEffort = phases.reduce((sum, phase) => sum + phase.estimatedEffort, 0);

    return {
      developers: Math.ceil(totalEffort / 40), // Assuming 40 hours per developer per phase
      securitySpecialists: phases.some(p => p.vulnerabilities.some(v => v.severity === 'critical')) ? 1 : 0,
      totalHours: totalEffort * 8, // Converting effort days to hours
      estimatedCost: totalEffort * 800 // Rough cost estimate
    };
  }

  private async generateRecommendedActions(vulnerability: Vulnerability): Promise<string[]> {
    const actions: string[] = [];

    switch (vulnerability.type) {
      case 'dependency':
        actions.push('Update to latest secure version');
        actions.push('Review changelog for breaking changes');
        actions.push('Run tests after update');
        break;

      case 'code':
        actions.push('Implement secure coding practices');
        actions.push('Add input validation');
        actions.push('Write comprehensive tests');
        break;

      case 'configuration':
        actions.push('Update configuration file');
        actions.push('Test configuration changes');
        actions.push('Document security settings');
        break;

      case 'infrastructure':
        actions.push('Update infrastructure as code');
        actions.push('Apply security hardening');
        actions.push('Review security group rules');
        break;
    }

    return actions;
  }
}

// Type definitions
export interface VulnerabilityTrends {
  timeframe: any;
  totalVulnerabilities: number;
  newVulnerabilities: number;
  resolvedVulnerabilities: number;
  trends: TrendData[];
  severityBreakdown: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  categoryBreakdown: {
    dependencies: number;
    code: number;
    configuration: number;
    infrastructure: number;
  };
}

export interface TrendData {
  date: string;
  count: number;
  severity: string;
}

export interface CachedVulnerability {
  vulnerability: Vulnerability;
  cachedAt: Date;
  ttl: number;
}

export interface RiskMatrix {
  matrix: Record<string, Record<string, number>>;
}

export interface RemediationStrategy {
  vulnerabilityType: string;
  patterns: string[];
  description: string;
  effortLevel: 'low' | 'medium' | 'high';
  automationLevel: 'low' | 'medium' | 'high';
  codeExamples: string[];
}

export interface AssessedVulnerability extends Vulnerability {
  riskScore: number;
  exploitability: ExploitabilityAssessment;
  impact: ImpactAssessment;
  priority: number;
  recommendedActions: string[];
}

export interface ExploitabilityAssessment {
  overallScore: number;
  factors: ExploitabilityFactor[];
  easeOfExploitation: 'very-easy' | 'easy' | 'moderate' | 'difficult' | 'very-difficult';
}

export interface ExploitabilityFactor {
  factor: string;
  score: number;
  description: string;
}

export interface ImpactAssessment {
  confidentialityImpact: 'none' | 'low' | 'medium' | 'high' | 'very-high';
  integrityImpact: 'none' | 'low' | 'medium' | 'high' | 'very-high';
  availabilityImpact: 'none' | 'low' | 'medium' | 'high' | 'very-high';
  factors: ImpactFactor[];
}

export interface ImpactFactor {
  factor: string;
  severity: string;
  description: string;
}

export interface CategorizedVulnerabilities {
  bySeverity: Record<string, AssessedVulnerability[]>;
  byType: Record<string, AssessedVulnerability[]>;
  byRiskScore: Record<string, AssessedVulnerability[]>;
  byLocation: Record<string, AssessedVulnerability[]>;
  byExploitability: Record<string, AssessedVulnerability[]>;
}

export interface VulnerabilitySummary {
  totalVulnerabilities: number;
  severityBreakdown: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  averageRiskScore: number;
  highRiskVulnerabilities: number;
  mostCommonType: string;
  highestRiskVulnerability: AssessedVulnerability | null;
}

export interface RemediationPlan {
  phases: RemediationPhase[];
  totalEstimatedEffort: number;
  recommendedTimeline: string;
  resourceRequirements: ResourceRequirement;
}

export interface RemediationPhase {
  phase: number;
  title: string;
  vulnerabilities: AssessedVulnerability[];
  estimatedEffort: number; // in days
  deadline: string;
  dependencies: number[];
}

export interface ResourceRequirement {
  developers: number;
  securitySpecialists: number;
  totalHours: number;
  estimatedCost: number;
}